EXE  = test
SRC  = test.c
OBJS = $(SRC:.c=.o)  # 将 SRC 变量中所有 .c 后缀的文件替换成 .o 后缀，在这个例子中，OBJS 的值将为 test.o

# 在 Makefile 中，${EXE} 和 $(EXE) 实际上是等价的：两者都是用于引用变量 EXE 的值
# * $(EXE)：这是最常见的变量引用方式，也是官方文档中推荐的格式
# * ${EXE}：这种形式也同样支持，尤其在嵌套变量或在某些复杂表达式中，使用这种方式可以增加可读性
# 选择哪一种形式主要取决于个人偏好或者是为了保持 Makefile 的一致性

# 在实际使用中，通常都会在 Makefile 文件中定义一个名为 all 的 target
# 并将其作为默认的 target（文件中第一个出现的 target），这样当用户执行 make 命令时，就相当于执行了 make all
# NOTE: all 不是 Makefile 官方定义的什么东西，只是一个“约定俗成”的名字
all: ${EXE}  # 当执行 make all 时，需要先执行 ${EXE} 这个 all 所依赖的 target
             # 而 all 自己又没有任何命令，所以这里就是起一个占位符的作用，当执行 make 时，就执行 all 所依赖的 target

${EXE}: ${OBJS}
	${CC} ${LDFLAGS} $< -o $@

# .c.o 是 Makefile 中的一个特殊的语法，是一个后缀规则（suffix rule）
# 后缀规则（suffix rule）用来定义如何从一个类型的文件生成另一个类型的文件
# .c.o 的意思是 Make 可以通过这个规则从任何 .c 文件生成 .o 文件（场景中通常是从 C 源代码文件编译生成对象文件）
# 这种后缀规则告诉 make 在目标需要更新的时候（.o 文件不存在或 .c 文件比 .o 文件新），该如何根据一个文件的后缀名.c来找到与之相关的目标文件（.o 文件），并执行对应的命令
.c.o:
	${CC} ${CFLAGS} -c $< -o $@
    # CC 是编译器，默认为 gcc
    # LDFLAGS 是链接器选项，默认为空
    # -c 表示只编译不链接
    # $< 是一个自动变量，它代表规则中的第一个依赖
    # * 在模式规则或后缀规则中，当编译一个 .c 文件生成 .o 文件时，$< 将会自动获取对应的 .c 文件的名称

# NOTE: 不过在新版的 Make 中，后缀规则已经被模式规则（pattern rules）取代，因为模式规则提供了更强的表现力和更清晰的语法，如下
# %.o: %.c
# 	$(CC) $(CFLAGS) -c $< -o $@

# clean 也是一个约定俗成的 target 的名字，用于删除所有由 make 创建的文件，保持工作目录的整洁
clean:
	@rm -rf ${OBJS} ${EXE}
    # 前缀 @ 表示：执行该命令时，不在命令行打印该命令，只打印命令的输出
    # 前缀 - 表示：执行该命令时，不检查命令的返回值，即使命令执行失败，也不报错
    # 前缀 + 表示：执行该命令时，不考虑 make 的执行模式（-n、-q、-t）

# .PHONY 告诉 make，clean 不是一个真正的文件名，它是一个伪目标
# 如果不进行该声明，那么当目录下有一个名为 clean 的文件时，make 就会认为 target 'clean' 已经存在，就不会执行 clean 规则了
# 因此，将 clean 声明为伪 target（PHONY）可以防止“存在一个名为 clean 的文件时，clean 规则不被执行”
.PHONY: clean
